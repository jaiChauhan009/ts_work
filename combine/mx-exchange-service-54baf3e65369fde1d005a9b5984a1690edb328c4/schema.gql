# ------------------------------------------------------
# THIS FILE WAS AUTOMATICALLY GENERATED (DO NOT MODIFY)
# ------------------------------------------------------

interface IAssets {
  website: String
  description: String
  status: String
  pngUrl: String
  svgUrl: String
  lockedAccounts: [String]
  extraTokens: [String]
}

interface IRoles {
  address: String
  canMint: Boolean
  canBurn: Boolean
  roles: [String]
}

type NftCollection implements INFTCollection {
  collection: String!
  name: String!
  ticker: String!
  decimals: Int!
  issuer: String!
  timestamp: Float!
  canUpgrade: Boolean!
  canMint: Boolean!
  canBurn: Boolean!
  canChangeOwner: Boolean!
  canPause: Boolean!
  canFreeze: Boolean!
  canWipe: Boolean!
  canAddSpecialRoles: Boolean!
  canTransferNFTCreateRole: Boolean!
  NFTCreateStopped: Boolean!
  assets: AssetsModel
  roles: RolesModel
}

interface INFTCollection {
  collection: String!
  name: String!
  ticker: String!
  decimals: Int!
  issuer: String!
  timestamp: Float!
  canUpgrade: Boolean!
  canMint: Boolean!
  canBurn: Boolean!
  canChangeOwner: Boolean!
  canPause: Boolean!
  canFreeze: Boolean!
  canWipe: Boolean!
  canAddSpecialRoles: Boolean!
  canTransferNFTCreateRole: Boolean!
  NFTCreateStopped: Boolean!
  assets: IAssets
  roles: IRoles
}

type FarmTokenAttributesModelV1_3 {
  identifier: String
  attributes: String
  rewardPerShare: String!
  enteringEpoch: Int!
  compoundedReward: String!
  currentFarmAmount: String!
  originalEnteringEpoch: Int!
  initialFarmingAmount: String!
}

type FarmTokenAttributesModelV1_2 {
  identifier: String
  attributes: String
  rewardPerShare: String!
  enteringEpoch: Int!
  compoundedReward: String!
  currentFarmAmount: String!
  originalEnteringEpoch: Int!
  initialFarmingAmount: String!
  aprMultiplier: Int
  lockedRewards: Boolean
}

type LockedTokenAttributesModel {
  identifier: String!
  attributes: String!
  originalTokenID: String!
  originalTokenNonce: Int!
  unlockEpoch: Int!
}

type WrappedLockedTokenAttributesModel {
  identifier: String!
  attributes: String!
  lockedTokenNonce: Int!
}

type LpProxyTokenAttributesModel {
  identifier: String!
  attributes: String!
  lpTokenID: String!
  firstTokenID: String!
  firstTokenLockedNonce: Int!
  firstTokenLockedAttributes: LockedTokenAttributesModel
  secondTokenID: String!
  secondTokenLockedNonce: Int!
  secondTokenLockedAttributes: LockedTokenAttributesModel
}

type FarmProxyTokenAttributesModel {
  identifier: String!
  attributes: String!
  farmType: String!
  farmTokenID: String!
  farmTokenNonce: Int!
  farmingTokenID: String!
  farmingTokenLockedNonce: Int!
  farmingTokenAttributes: LpProxyTokenAttributesModel!
  farmTokenAttributes: FarmTokenAttributes!
}

union FarmTokenAttributes = FarmTokenAttributesModelV1_2 | FarmTokenAttributesModelV1_3 | FarmTokenAttributesModelV2

type FarmTokenAttributesModelV2 {
  identifier: String
  attributes: String
  rewardPerShare: String!
  enteringEpoch: Int!
  compoundedReward: String!
  currentFarmAmount: String!
}

type SimpleLockModel {
  address: String!
  lockedToken: NftCollection!
  lpProxyToken: NftCollection!
  farmProxyToken: NftCollection!
  intermediatedPairs: [String!]!
  intermediatedFarms: [String!]!
}

type EnableSwapByUserConfig {
  lockingSC: SimpleLockModel!
  commonTokenID: String!
  minLockedTokenValue: String!
  minLockPeriodEpochs: Int!
}

type FactoryModel {
  address: String!
  state: Boolean!
  owner: String!
  temporaryOwnerPeriod: String!
  pairCount: Float!
  pairCreationEnabled: Boolean!
  pairTemplateAddress: String!
  totalTxCount: Float!
  totalValueLockedUSD: String!
  totalVolumeUSD24h: String!
  totalFeesUSD24h: String!
  maintenance: Boolean!
  multiSwapStatus: Boolean!
  commonTokensForUserPairs: [String!]!
  enableSwapByUserConfig: [EnableSwapByUserConfig!]!
  defaultSlippage: Float!
  slippageValues: [Float!]!
  minSlippage: Float!
  maxSlippage: Float!
  minSwapAmount: Float!
}

type AssetsModel implements IAssets {
  website: String
  description: String
  status: String
  pngUrl: String
  svgUrl: String
  lockedAccounts: [String]
  extraTokens: [String]
}

type RolesModel implements IRoles {
  address: String
  canMint: Boolean
  canBurn: Boolean
  roles: [String]
}

type DcdtToken implements IDcdtToken {
  identifier: String!
  name: String!
  ticker: String!
  owner: String!
  minted: String
  burnt: String
  initialMinted: String
  decimals: Float!
  price: String!
  supply: String
  circulatingSupply: String
  assets: AssetsModel
  transactions: Int!
  accounts: Int!
  isPaused: Boolean!
  canUpgrade: Boolean!
  canMint: Boolean!
  canBurn: Boolean!
  canChangeOwner: Boolean!
  canPause: Boolean!
  canFreeze: Boolean!
  canWipe: Boolean!
  roles: RolesModel
  type: String!
  balance: String
  derivedEGLD: String!
}

interface IDcdtToken {
  identifier: String!
  name: String!
  ticker: String!
  owner: String!
  minted: String
  burnt: String
  initialMinted: String
  decimals: Float!
  price: String
  supply: String
  circulatingSupply: String
  assets: IAssets
  transactions: Int!
  accounts: Int!
  isPaused: Boolean!
  canUpgrade: Boolean!
  canMint: Boolean!
  canBurn: Boolean!
  canChangeOwner: Boolean!
  canPause: Boolean!
  canFreeze: Boolean!
  canWipe: Boolean!
  roles: IRoles
  type: String
  balance: String
}

type PairInfoModel {
  reserves0: String!
  reserves1: String!
  totalSupply: String!
}

type WeekTimekeepingModel {
  scAddress: String!
  firstWeekStartEpoch: Float!
  currentWeek: Float!
  startEpochForWeek: Float!
  endEpochForWeek: Float!
}

type WeekForEpochModel {
  scAddress: String!
  epoch: Float!
  week: Float!
}

type EnergyModel {
  amount: String!
  lastUpdateEpoch: Int!
  totalLockedTokens: String!
}

type DcdtTokenPayment {
  tokenType: Int
  tokenID: String!
  nonce: Int!
  amount: String!
}

type TokenDistributionModel {
  tokenId: String!
  percentage: String!
}

type GlobalInfoByWeekModel {
  scAddress: String!
  week: Float!
  apr: String!
  totalRewardsForWeek: [DcdtTokenPayment!]!
  rewardsDistributionForWeek: [TokenDistributionModel!]!
  totalEnergyForWeek: String!
  totalLockedTokensForWeek: String!
}

type UserInfoByWeekModel {
  scAddress: String!
  userAddress: String!
  week: Float!
  apr: String!
  positionAmount: String
  energyForWeek: EnergyModel!
  rewardsForWeek: [DcdtTokenPayment!]!
  rewardsDistributionForWeek: [TokenDistributionModel!]!
}

type ClaimProgress {
  energy: EnergyModel!
  week: Int!
}

type TransactionModel {
  nonce: Float!
  value: String!
  sender: String!
  receiver: String!
  gasPrice: Float!
  gasLimit: Float!
  data: String
  chainID: String!
  version: Float!
  options: Float
  status: String
  signature: String
}

type FeesCollectorModel {
  address: String!
  time: WeekTimekeepingModel!
  startWeek: Float!
  endWeek: Float!
  lastGlobalUpdateWeek: Float!
  undistributedRewards: [GlobalInfoByWeekModel!]!
  allTokens: [String!]!
  knownContracts: [String!]!
  accumulatedFees: [DcdtTokenPayment!]!
  lockedTokenId: String!
  lockedTokensPerBlock: String!
}

type UserEntryFeesCollectorModel {
  address: String!
  userAddress: String!
  time: WeekTimekeepingModel!
  startWeek: Float!
  endWeek: Float!
  undistributedRewards: [UserInfoByWeekModel!]!
  accumulatedRewards: [DcdtTokenPayment!]!
  claimProgress: ClaimProgress!
  lastActiveWeekForUser: Float!
}

type FeesCollectorTransactionModel {
  transaction: TransactionModel
  count: Int!
}

type LiquidityPosition {
  firstTokenAmount: String!
  secondTokenAmount: String!
}

type LockedTokensInfo {
  lockingScAddress: String! @deprecated(reason: "field is deprecated and will be removed on next release;value can be obtained from lockingSC field")
  lockingSC: SimpleLockModel!
  unlockEpoch: Int!
  lockingDeadlineEpoch: Int!
}

type PairModel {
  address: String!
  firstToken: DcdtToken!
  secondToken: DcdtToken!
  firstTokenPrice: String!
  firstTokenPriceUSD: String!
  secondTokenPrice: String!
  secondTokenPriceUSD: String!
  liquidityPoolToken: DcdtToken!
  liquidityPoolTokenPriceUSD: String!
  firstTokenLockedValueUSD: String!
  secondTokenLockedValueUSD: String!
  lockedValueUSD: String!
  firstTokenVolume24h: String!
  secondTokenVolume24h: String!
  volumeUSD24h: String!
  feesUSD24h: String!
  feesAPR: String!
  info: PairInfoModel!
  totalFeePercent: Float!
  specialFeePercent: Float!

  """Percentage of special fees that go to the fees collector"""
  feesCollectorCutPercentage: Float!
  trustedSwapPairs: [String!]!
  type: String!
  state: String!
  feeState: Boolean!
  lockedTokensInfo: LockedTokensInfo
  whitelistedManagedAddresses: [String!]!
  initialLiquidityAdder: String!
  feeDestinations: [FeeDestination!]!

  """Fees collector set for this pair"""
  feesCollector: FeesCollectorModel
}

type FeeDestination {
  address: String!
  tokenID: String!
}

type RewardsModel {
  identifier: String!
  rewards: String!
  remainingFarmingEpochs: Int
  boostedRewardsWeeklyInfo: [UserInfoByWeekModel!]
  claimProgress: ClaimProgress
  accumulatedRewards: String
}

type ExitFarmTokensModel {
  farmingTokens: String!
  rewards: String!
}

type FarmMigrationConfig {
  migrationRole: String!
  oldFarmAddress: String!
  oldFarmTokenID: String!
  newFarmAddress: String
  newLockedFarmAddress: String
}

type HistoricDataModel {
  timestamp: String!
  value: String!
}

type PairDayDataModel {
  timestamp: String!
  address: String!
  firstToken: DcdtToken!
  secondToken: DcdtToken!
  lockedValueUSD: String!
  firstTokenPriceUSD: String!
  secondTokenPriceUSD: String!
  volumeUSD24h: String!
  feesUSD24h: String!
}

type WrapModel {
  address: String!
  shard: Int!
  wrappedToken: DcdtToken!
}

type NftToken implements INFTToken {
  identifier: String!
  collection: String!
  ticker: String!
  decimals: Int!
  timestamp: Int
  attributes: String!
  nonce: Int!
  type: String!
  name: String!
  creator: String!
  royalties: Int
  uris: [String!]
  url: String
  tags: [String!]
  balance: String!
  assets: AssetsModel
}

interface INFTToken {
  identifier: String!
  collection: String!
  ticker: String!
  decimals: Int!
  timestamp: Int
  attributes: String!
  nonce: Int!
  type: String!
  name: String!
  creator: String!
  royalties: Int
  uris: [String!]
  url: String
  tags: [String!]
  balance: String!
  assets: IAssets
}

type UnlockMileStoneModel {
  epochs: Int!
  percent: Float!
}

type LockedAssetAttributesModel {
  attributes: String!
  identifier: String!
  unlockSchedule: [UnlockMileStoneModel!]!
  isMerged: Boolean!
}

type LockedAssetModel {
  address: String!
  assetToken: DcdtToken!
  lockedToken: NftCollection!
  unlockMilestones: [UnlockMileStoneModel!]!
  activationNonce: Int!
}

type BoostedYieldsFactors {
  maxRewardsFactor: String!
  userRewardsEnergy: String!
  userRewardsFarm: String!
  minEnergyAmount: String!
  minFarmAmount: String!
}

type LockOption {
  lockEpochs: Int!
  penaltyStartPercentage: Int!
}

type SimpleLockEnergyModel {
  address: String!
  baseAssetToken: DcdtToken!
  lockedToken: NftCollection!
  legacyLockedToken: NftCollection!
  lockOptions: [LockOption!]!
  tokenUnstakeAddress: String!
  pauseState: Boolean!
}

type CommunityDistributionModel {
  epoch: Float!
  amount: String!
}

type DistributionModel {
  address: String!
  communityDistribution: CommunityDistributionModel!
}

type DcdtTokenPaymentModel {
  tokenIdentifier: String!
  tokenNonce: Float!
  amount: String!
}

type WrappedLpTokenAttributesModel {
  identifier: String!
  attributes: String!
  lpTokenID: String!
  lpTokenTotalAmount: String!
  lockedAssetsInvested: String!
  lockedAssetsNonce: Int!
  lockedAssetsAttributes: LockedAssetAttributesModel!
}

type WrappedLpTokenAttributesModelV2 {
  identifier: String!
  attributes: String!
  lpTokenID: String!
  lpTokenAmount: String!
  lockedTokens: DcdtTokenPaymentModel!
  lockedAssetsAttributes: LockedAssetAttributesUnion!
}

union LockedAssetAttributesUnion = LockedAssetAttributesModel | LockedTokenAttributesModel

type WrappedFarmTokenAttributesModel {
  identifier: String!
  attributes: String!
  farmTokenID: String!
  farmTokenNonce: Int!
  farmTokenAmount: String!
  farmTokenIdentifier: String!
  farmTokenAttributes: FarmTokenAttributes!
  farmingTokenID: String!
  farmingTokenNonce: Int!
  farmingTokenAmount: String!
  lockedAssetsAttributes: LockedAssetAttributesModel
  lockedLpProxyTokenAttributes: WrappedLpTokenAttributesModel
}

type WrappedFarmTokenAttributesModelV2 {
  identifier: String!
  attributes: String!
  farmToken: DcdtTokenPaymentModel!
  proxyFarmingToken: DcdtTokenPaymentModel!
  farmTokenAttributes: FarmTokenAttributes!
  lockedLpProxyTokenAttributes: WrappedLpTokenAttributesModelV2
}

type ProxyModel {
  address: String!
  lockedAssetTokens: [NftCollection!]!
  wrappedLpToken: NftCollection!
  wrappedFarmToken: NftCollection!
  assetToken: DcdtToken!
  intermediatedPairs: [String!]!
  intermediatedFarms: [String!]!
  version: String!
}

type StakingTokenAttributesModel {
  identifier: String
  attributes: String
  type: StakingTokenType!
  rewardPerShare: String!
  compoundedReward: String!
  currentFarmAmount: String!
}

enum StakingTokenType {
  STAKING_FARM_TOKEN
  UNBOND_FARM_TOKEN
}

type UnbondTokenAttributesModel {
  identifier: String
  attributes: String
  type: StakingTokenType!
  remainingEpochs: Int!
}

type DualYieldTokenAttributesModel {
  identifier: String!
  attributes: String!
  lpFarmTokenNonce: Int!
  lpFarmTokenAmount: String!
  stakingFarmTokenNonce: Int!
  stakingFarmTokenAmount: String!
}

type UserToken implements IDcdtToken {
  identifier: String!
  name: String!
  ticker: String!
  owner: String!
  minted: String
  burnt: String
  initialMinted: String
  decimals: Float!
  price: String!
  supply: String
  circulatingSupply: String
  assets: AssetsModel
  transactions: Int!
  accounts: Int!
  isPaused: Boolean!
  canUpgrade: Boolean!
  canMint: Boolean!
  canBurn: Boolean!
  canChangeOwner: Boolean!
  canPause: Boolean!
  canFreeze: Boolean!
  canWipe: Boolean!
  roles: RolesModel
  type: String!
  balance: String
  derivedEGLD: String!
  valueUSD: String!
}

type UserLockedAssetToken implements INFTToken {
  identifier: String!
  collection: String!
  ticker: String!
  decimals: Int!
  timestamp: Int
  attributes: String!
  nonce: Int!
  type: String!
  name: String!
  creator: String!
  royalties: Int
  uris: [String!]
  url: String
  tags: [String!]
  balance: String!
  assets: AssetsModel
  decodedAttributes: LockedAssetAttributesModel!
  valueUSD: String!
}

type UserFarmToken implements INFTToken {
  identifier: String!
  collection: String!
  ticker: String!
  decimals: Int!
  timestamp: Int
  attributes: String!
  nonce: Int!
  type: String!
  name: String!
  creator: String!
  royalties: Int
  uris: [String!]
  url: String
  tags: [String!]
  balance: String!
  assets: AssetsModel
  decodedAttributes: FarmTokenAttributes!
  valueUSD: String!
}

type UserLockedLPToken implements INFTToken {
  identifier: String!
  collection: String!
  ticker: String!
  decimals: Int!
  timestamp: Int
  attributes: String!
  nonce: Int!
  type: String!
  name: String!
  creator: String!
  royalties: Int
  uris: [String!]
  url: String
  tags: [String!]
  balance: String!
  assets: AssetsModel
  decodedAttributes: WrappedLpTokenAttributesModel!
  valueUSD: String!
}

type UserLockedFarmToken implements INFTToken {
  identifier: String!
  collection: String!
  ticker: String!
  decimals: Int!
  timestamp: Int
  attributes: String!
  nonce: Int!
  type: String!
  name: String!
  creator: String!
  royalties: Int
  uris: [String!]
  url: String
  tags: [String!]
  balance: String!
  assets: AssetsModel
  decodedAttributes: WrappedFarmTokenAttributesModel!
  valueUSD: String!
}

type UserLockedLPTokenV2 implements INFTToken {
  identifier: String!
  collection: String!
  ticker: String!
  decimals: Int!
  timestamp: Int
  attributes: String!
  nonce: Int!
  type: String!
  name: String!
  creator: String!
  royalties: Int
  uris: [String!]
  url: String
  tags: [String!]
  balance: String!
  assets: AssetsModel
  decodedAttributes: WrappedLpTokenAttributesModelV2!
  valueUSD: String!
}

type UserLockedFarmTokenV2 implements INFTToken {
  identifier: String!
  collection: String!
  ticker: String!
  decimals: Int!
  timestamp: Int
  attributes: String!
  nonce: Int!
  type: String!
  name: String!
  creator: String!
  royalties: Int
  uris: [String!]
  url: String
  tags: [String!]
  balance: String!
  assets: AssetsModel
  decodedAttributes: WrappedFarmTokenAttributesModelV2!
  valueUSD: String!
}

type UserStakeFarmToken implements INFTToken {
  identifier: String!
  collection: String!
  ticker: String!
  decimals: Int!
  timestamp: Int
  attributes: String!
  nonce: Int!
  type: String!
  name: String!
  creator: String!
  royalties: Int
  uris: [String!]
  url: String
  tags: [String!]
  balance: String!
  assets: AssetsModel
  decodedAttributes: StakingTokenAttributesModel!
  valueUSD: String!
}

type UserUnbondFarmToken implements INFTToken {
  identifier: String!
  collection: String!
  ticker: String!
  decimals: Int!
  timestamp: Int
  attributes: String!
  nonce: Int!
  type: String!
  name: String!
  creator: String!
  royalties: Int
  uris: [String!]
  url: String
  tags: [String!]
  balance: String!
  assets: AssetsModel
  decodedAttributes: UnbondTokenAttributesModel!
  valueUSD: String!
}

type UserDualYiledToken implements INFTToken {
  identifier: String!
  collection: String!
  ticker: String!
  decimals: Int!
  timestamp: Int
  attributes: String!
  nonce: Int!
  type: String!
  name: String!
  creator: String!
  royalties: Int
  uris: [String!]
  url: String
  tags: [String!]
  balance: String!
  assets: AssetsModel
  decodedAttributes: DualYieldTokenAttributesModel!
  valueUSD: String!
}

type UserRedeemToken implements INFTToken {
  identifier: String!
  collection: String!
  ticker: String!
  decimals: Int!
  timestamp: Int
  attributes: String!
  nonce: Int!
  type: String!
  name: String!
  creator: String!
  royalties: Int
  uris: [String!]
  url: String
  tags: [String!]
  balance: String!
  assets: AssetsModel
  valueUSD: String!
}

type UserLockedDcdtToken implements INFTToken {
  identifier: String!
  collection: String!
  ticker: String!
  decimals: Int!
  timestamp: Int
  attributes: String!
  nonce: Int!
  type: String!
  name: String!
  creator: String!
  royalties: Int
  uris: [String!]
  url: String
  tags: [String!]
  balance: String!
  assets: AssetsModel
  decodedAttributes: LockedTokenAttributesModel!
  valueUSD: String!
}

type UserLockedSimpleLpToken implements INFTToken {
  identifier: String!
  collection: String!
  ticker: String!
  decimals: Int!
  timestamp: Int
  attributes: String!
  nonce: Int!
  type: String!
  name: String!
  creator: String!
  royalties: Int
  uris: [String!]
  url: String
  tags: [String!]
  balance: String!
  assets: AssetsModel
  decodedAttributes: LpProxyTokenAttributesModel!
  valueUSD: String!
}

type UserLockedSimpleFarmToken implements INFTToken {
  identifier: String!
  collection: String!
  ticker: String!
  decimals: Int!
  timestamp: Int
  attributes: String!
  nonce: Int!
  type: String!
  name: String!
  creator: String!
  royalties: Int
  uris: [String!]
  url: String
  tags: [String!]
  balance: String!
  assets: AssetsModel
  decodedAttributes: FarmProxyTokenAttributesModel!
  valueUSD: String!
}

type UserLockedTokenEnergy implements INFTToken {
  identifier: String!
  collection: String!
  ticker: String!
  decimals: Int!
  timestamp: Int
  attributes: String!
  nonce: Int!
  type: String!
  name: String!
  creator: String!
  royalties: Int
  uris: [String!]
  url: String
  tags: [String!]
  balance: String!
  assets: AssetsModel
  decodedAttributes: LockedTokenAttributesModel!
  valueUSD: String!
}

type UserWrappedLockedToken implements INFTToken {
  identifier: String!
  collection: String!
  ticker: String!
  decimals: Int!
  timestamp: Int
  attributes: String!
  nonce: Int!
  type: String!
  name: String!
  creator: String!
  royalties: Int
  uris: [String!]
  url: String
  tags: [String!]
  balance: String!
  assets: AssetsModel
  valueUSD: String!
  lockedTokenNonce: Float!
  decodedAttributes: WrappedLockedTokenAttributesModel!
}

type UserNftsModel {
  address: String!
  userLockedAssetToken: [UserLockedAssetToken!]!
  userFarmToken: [UserFarmToken!]!
  userLockedLPToken: [UserLockedLPToken!]!
  userLockedFarmToken: [UserLockedFarmToken!]!
  userLockedLpTokenV2: [UserLockedLPTokenV2!]!
  userLockedFarmTokenV2: [UserLockedFarmTokenV2!]!
  userStakeFarmToken: [UserStakeFarmToken!]!
  userUnbondFarmToken: [UserUnbondFarmToken!]!
  userDualYieldToken: [UserDualYiledToken!]!
  userRedeemToken: [UserRedeemToken!]!
  userLockedDcdtToken: [UserLockedDcdtToken!]!
  userLockedSimpleLpToken: [UserLockedSimpleLpToken!]!
  userLockedSimpleFarmToken: [UserLockedSimpleFarmToken!]!
  userLockedTokenEnergy: [UserLockedTokenEnergy!]!
  userWrappedLockedToken: [UserWrappedLockedToken!]!
}

type OutdatedContract {
  address: String!
  type: String!
  claimProgressOutdated: Boolean!
  farmToken: String
}

type StakingModel {
  address: String!
  farmToken: NftCollection!
  farmingToken: DcdtToken!
  rewardToken: DcdtToken!
  farmTokenSupply: String!
  pairContractManagedAddress: String!
  rewardPerShare: String!
  accumulatedRewards: String!
  rewardCapacity: String!
  annualPercentageRewards: String!
  apr: String!
  minUnboundEpochs: Int!
  perBlockRewards: String!
  lastRewardBlockNonce: Int!
  divisionSafetyConstant: String!
  produceRewardsEnabled: Boolean!
  lockedAssetFactoryManagedAddress: String
  burnGasLimit: String
  transferExecGasLimit: String
  state: String!
}

type StakingRewardsModel {
  decodedAttributes: StakingTokenAttributesModel!
  rewards: String!
}

type OptimalCompoundModel {
  """The optimal number of compounds in the given interval"""
  interval: Int!
  optimalProfit: Float!
  days: Int!
  hours: Int!
  minutes: Int!
}

type StakingProxyModel {
  address: String!
  lpFarmAddress: String!
  stakingFarmAddress: String!
  pairAddress: String!
  stakingToken: DcdtToken!
  farmToken: NftCollection!
  dualYieldToken: NftCollection!
  lpFarmToken: NftCollection!
}

type DualYieldRewardsModel {
  identifier: String
  attributes: String
  stakingRewards: StakingRewardsModel!
  farmRewards: RewardsModel!
}

type UnstakeFarmTokensReceiveModel {
  liquidityPosition: LiquidityPosition!
  farmRewards: String!
  stakingRewards: String!
}

type PhaseModel {
  name: String!
  penaltyPercent: Float!
}

type PriceDiscoveryModel {
  address: String!
  launchedToken: DcdtToken!
  acceptedToken: DcdtToken!
  redeemToken: NftCollection!
  launchedTokenAmount: String!
  acceptedTokenAmount: String!
  launchedTokenRedeemBalance: String!
  acceptedTokenRedeemBalance: String!
  launchedTokenPrice: String!
  acceptedTokenPrice: String!
  launchedTokenPriceUSD: String!
  acceptedTokenPriceUSD: String!
  startBlock: Float!
  endBlock: Float!
  currentPhase: PhaseModel!
  minLaunchedTokenPrice: String!
  noLimitPhaseDurationBlocks: Int!
  linearPenaltyPhaseDurationBlocks: Int!
  fixedPenaltyPhaseDurationBlocks: Int!
  lockingSC: SimpleLockModel!
  lockingScAddress: String! @deprecated(reason: "field is deprecated and will be removed on next release;value can be obtained from lockingSC field")
  unlockEpoch: Int!
  penaltyMinPercentage: Float!
  penaltyMaxPercentage: Float!
  fixedPenaltyPercentage: Float!
}

type LockedTokenWrapperModel {
  address: String!
  lockedTokenId: String!
  wrappedTokenId: String!
  energyFactoryAddress: String!
}

type UpdatedEnergyEventModel {
  oldEnergyEntry: EnergyModel!
  newEnergyEntry: EnergyModel!
}

type GenericToken {
  tokenID: String!
  nonce: Int!
  amount: String!
}

type FarmEventModelV1_3 {
  address: String!
  caller: String!
  block: Int!
  epoch: Int!
  timestamp: Int!
  farmingToken: GenericToken!
  farmingReserve: String!
  farmToken: GenericToken!
  farmSupply: String!
  rewardToken: GenericToken!
  rewardTokenReserves: String!
  createdWithMerge: Boolean!
  farmAttributes: FarmTokenAttributesModelV1_3!
}

type RewardsFarmEventModelV1_3 {
  address: String!
  caller: String!
  block: Int!
  epoch: Int!
  timestamp: Int!
  oldFarmToken: GenericToken!
  newFarmToken: GenericToken!
  farmSupply: String!
  rewardToken: GenericToken!
  rewardTokenReserves: String!
  createdWithMerge: Boolean!
  oldFarmAttributes: FarmTokenAttributesModelV1_3!
  newFarmAttributes: FarmTokenAttributesModelV1_3!
}

type AddLiquidityEventModel {
  address: String!
  caller: String!
  block: Int!
  epoch: Int!
  timestamp: Int!
  firstToken: GenericToken!
  secondToken: GenericToken!
  liquidityPoolToken: GenericToken!
  liquidityPoolSupply: String!
  firstTokenReserves: String!
  secondTokenReserves: String!
}

type RemoveLiquidityEventModel {
  address: String!
  caller: String!
  block: Int!
  epoch: Int!
  timestamp: Int!
  firstToken: GenericToken!
  secondToken: GenericToken!
  liquidityPoolToken: GenericToken!
  liquidityPoolSupply: String!
  firstTokenReserves: String!
  secondTokenReserves: String!
}

type SwapFixedInputEventModel {
  address: String!
  caller: String!
  block: Int!
  epoch: Int!
  timestamp: Int!
  tokenIn: GenericToken!
  tokenOut: GenericToken!
  feeAmount: String!
  tokenInReserves: String!
  tokenOutReserves: String!
}

type SwapFixedOutputEventModel {
  address: String!
  caller: String!
  block: Int!
  epoch: Int!
  timestamp: Int!
  tokenIn: GenericToken!
  tokenOut: GenericToken!
  feeAmount: String!
  tokenInReserves: String!
  tokenOutReserves: String!
}

type SwapNoFeeEventModel {
  address: String!
  caller: String!
  block: Int!
  epoch: Int!
  timestamp: Int!
  tokenIn: GenericToken!
  tokenOut: GenericToken!
  destination: String!
}

type PairProxyEventModel {
  address: String!
  caller: String!
  block: Int!
  epoch: Int!
  timestamp: Int!
  firstToken: GenericToken!
  secondToken: GenericToken!
  wrappedLpToken: GenericToken!
  wrappedLpAttributes: WrappedLpTokenAttributesModel!
}

type AddLiquidityProxyEventModel {
  address: String!
  caller: String!
  block: Int!
  epoch: Int!
  timestamp: Int!
  firstToken: GenericToken!
  secondToken: GenericToken!
  wrappedLpToken: GenericToken!
  wrappedLpAttributes: WrappedLpTokenAttributesModel!
  createdWithMerge: Boolean!
}

type RewardsProxyEventModel {
  address: String!
  caller: String!
  block: Int!
  epoch: Int!
  timestamp: Int!
  farmAddress: String!
  oldWrappedFarmToken: GenericToken!
  newWrappedFarmToken: GenericToken!
  oldWrappedFarmAttributes: WrappedFarmTokenAttributesModel!
  newWrappedFarmAttributes: WrappedFarmTokenAttributesModel!
  createdWithMerge: Boolean!
}

type ClaimRewardsProxyEventModel {
  address: String!
  caller: String!
  block: Int!
  epoch: Int!
  timestamp: Int!
  farmAddress: String!
  oldWrappedFarmToken: GenericToken!
  newWrappedFarmToken: GenericToken!
  oldWrappedFarmAttributes: WrappedFarmTokenAttributesModel!
  newWrappedFarmAttributes: WrappedFarmTokenAttributesModel!
  createdWithMerge: Boolean!
  rewardToken: GenericToken!
}

type ExitFarmProxyEventModel {
  address: String!
  caller: String!
  block: Int!
  epoch: Int!
  timestamp: Int!
  farmAddress: String!
  wrappedFarmToken: GenericToken!
  wrappedFarmAttributes: WrappedFarmTokenAttributesModel!
  farmingToken: GenericToken!
  rewardToken: GenericToken!
}

type EnterFarmProxyEventModel {
  address: String!
  caller: String!
  block: Int!
  epoch: Int!
  timestamp: Int!
  farmAddress: String!
  wrappedFarmToken: GenericToken!
  wrappedFarmAttributes: WrappedFarmTokenAttributesModel!
  farmingToken: GenericToken!
  rewardToken: GenericToken!
  createdWithMerge: Boolean!
}

type MetabondingStakingModel {
  address: String!
  lockedAssetToken: NftCollection!
  lockedAssetTokenSupply: String!
  unbondEpochs: Int!
}

type UserEntryModel {
  tokenNonce: Int!
  stakedAmount: String!
  unstakedAmount: String!
  unbondEpoch: Float
}

type AutoRouteModel {
  swapType: Float!
  tokenInID: String!
  tokenOutID: String!
  tokenInExchangeRate: String!
  tokenOutExchangeRate: String!
  tokenInExchangeRateDenom: String!
  tokenOutExchangeRateDenom: String!
  tokenInPriceUSD: String!
  tokenOutPriceUSD: String!
  amountIn: String
  amountOut: String
  intermediaryAmounts: [String!]!
  tokenRoute: [String!]!
  fees: [String!]!
  pricesImpact: [String!]!
  maxPriceDeviationPercent: Float!
  tokensPriceDeviationPercent: Float
  pairs: [PairModel!]!
  tolerance: Float!
  transactions: [TransactionModel!]
}

type TokenUnstakeModel {
  address: String!
  unbondEpochs: Int!
  feesBurnPercentage: Int!
  feesCollectorAddress: String!
  energyFactoryAddress: String!
}

type UnstakePairModel {
  unlockEpoch: Float!
  lockedTokens: DcdtTokenPaymentModel!
  unlockedTokens: DcdtTokenPaymentModel!
}

type EscrowModel {
  address: String!
  energyFactoryAddress: String!
  lockedTokenID: String!
  minLockEpochs: Float!
  epochsCooldownDuration: Float!
}

type LockedFundsModel {
  funds: [DcdtTokenPaymentModel!]!
  lockedEpoch: Float!
}

type ScheduledTransferModel {
  sender: String!
  lockedFunds: LockedFundsModel!
}

type ProposalVotes {
  upVotes: String!
  downVotes: String!
  downVetoVotes: String!
  abstainVotes: String!
  totalVotes: String!
  upPercentage: String!
  downPercentage: String!
  downVetoPercentage: String!
  abstainPercentage: String!
  quorum: String!
}

type GovernanceAction {
  gasLimit: Int!
  destAddress: String!
  functionName: String!
  arguments: [String!]!
}

type GovernanceProposalModel {
  contractAddress: String!
  proposalId: Float!
  proposer: String!
  actions: [GovernanceAction!]!
  description: GovernanceDescriptionVersions!
  feePayment: DcdtTokenPaymentModel!
  minimumQuorum: String!
  votingDelayInBlocks: Int!
  votingPeriodInBlocks: Int!
  withdrawPercentageDefeated: Int!
  totalQuorum: String!
  proposalStartBlock: Int!
  status: String!
  votes: ProposalVotes!
  hasVoted: Boolean!
  userVotingPower: String!
}

union GovernanceDescriptionVersions = Description_v0 | Description_v1

type Description_v0 {
  title: String!
  hash: String!
  strapiId: Int!
  version: Float!
}

type Description_v1 {
  title: String!
  hash: String!
  strapiId: Int!
  version: Float!
  shortDescription: String!
}

input DcdtTokenPaymentInput {
  tokenType: Int
  tokenID: String!
  nonce: Int!
  amount: String!
}

type Query {
  factory: FactoryModel!
  pairAddresses: [String!]!
  pairs(offset: Int! = 0, limit: Int! = 10, address: String, firstTokenID: String, secondTokenID: String, issuedLpToken: Boolean! = true, state: String): [PairModel!]!
  createPair(firstTokenID: String!, secondTokenID: String!): TransactionModel!
  upgradePair(firstTokenID: String!, secondTokenID: String!, fees: [Float!]!): TransactionModel!
  issueLPToken(address: String!, lpTokenName: String!, lpTokenTicker: String!): TransactionModel!
  setLocalRoles(address: String!): TransactionModel!
  setState(address: String!, enable: Boolean!): TransactionModel!
  setFee(pairAddress: String!, feeToAddress: String!, feeTokenID: String!, enable: Boolean!): TransactionModel!
  setPairCreationEnabled(enabled: Boolean!): TransactionModel!
  clearPairTemporaryOwnerStorage: TransactionModel!
  setTemporaryOwnerPeriod(periodBlocks: String!): TransactionModel!
  setPairTemplateAddress(address: String!): TransactionModel!
  setLocalRolesOwner(args: SetLocalRoleOwnerArgs!): TransactionModel!
  removePair(firstTokenID: String!, secondTokenID: String!): TransactionModel!
  setSwapEnabledByUser(inputTokens: InputTokenModel!): TransactionModel!
  getAmountOut(pairAddress: String!, tokenInID: String!, amount: String!): String!
  getAmountIn(pairAddress: String!, tokenOutID: String!, amount: String!): String!
  getEquivalent(pairAddress: String!, tokenInID: String!, amount: String!): String!
  getLiquidityPosition(pairAddress: String!, liquidityAmount: String!): LiquidityPosition!
  getFeeState(pairAddress: String!): Boolean!
  getRouterManagedAddress(address: String!): String!
  addInitialLiquidityBatch(pairAddress: String!, tokens: [InputTokenModel!]!, tolerance: Float!): [TransactionModel!]!
  addLiquidityBatch(pairAddress: String!, tokens: [InputTokenModel!]!, tolerance: Float!): [TransactionModel!]!
  updateAndGetSafePrice(pairAddress: String!, dcdtTokenPayment: DcdtTokenPaymentInput!): DcdtTokenPayment!
  addLiquidity(pairAddress: String!, tokens: [InputTokenModel!]!, tolerance: Float!): TransactionModel!
  removeLiquidity(pairAddress: String!, liquidity: String!, liquidityTokenID: String!, tolerance: Float!): [TransactionModel!]!
  swapTokensFixedInput(pairAddress: String!, tokenInID: String!, amountIn: String!, tokenOutID: String!, amountOut: String!, tolerance: Float!): [TransactionModel!]!
  swapTokensFixedOutput(pairAddress: String!, tokenInID: String!, amountIn: String!, tokenOutID: String!, amountOut: String!): [TransactionModel!]!
  whitelist(pairAddress: String!, address: String!): TransactionModel!
  removeWhitelist(pairAddress: String!, address: String!): TransactionModel!
  addTrustedSwapPair(pairAddress: String!, swapPairAddress: String!, firstTokenID: String!, secondTokenID: String!): TransactionModel!
  removeTrustedSwapPair(pairAddress: String!, firstTokenID: String!, secondTokenID: String!): TransactionModel!
  pausePair(pairAddress: String!): TransactionModel!
  resumePair(pairAddress: String!): TransactionModel!
  setStateActiveNoSwaps(pairAddress: String!): TransactionModel!
  setFeePercents(pairAddress: String!, totalFeePercent: Float!, specialFeePercent: Float!): TransactionModel!
  setLockingDeadlineEpoch(pairAddress: String!, newDeadline: Float!): TransactionModel!
  setLockingScAddress(pairAddress: String!, newAddress: String!): TransactionModel!
  setUnlockEpoch(pairAddress: String!, newEpoch: Float!): TransactionModel!

  """
  Generate transaction to set the fees collector address and fees cut percentage for a pair
  """
  setupFeesCollector(pairAddress: String!): TransactionModel!
  wrappingInfo: [WrapModel!]!
  wrapEgld(amount: String!): TransactionModel!
  unwrapEgld(amount: String!): TransactionModel!
  tokens(identifiers: [String!], type: String, enabledSwaps: Boolean! = false): [DcdtToken!]!
  nftToken(identifier: String!): NftToken!
  simpleLock: [SimpleLockModel!]!
  lockedTokenAttributes(args: DecodeAttributesArgs!): [LockedTokenAttributesModel!]!
  lpProxyTokenAttributes(args: DecodeAttributesArgs!): [LpProxyTokenAttributesModel!]!
  farmProxyTokenAttributes(args: DecodeAttributesArgs!): [FarmProxyTokenAttributesModel!]!
  lockTokens(inputTokens: InputTokenModel!, lockEpochs: Float!, simpleLockAddress: String!): TransactionModel!
  unlockTokens(inputTokens: InputTokenModel!): TransactionModel!
  addLiquidityLockedTokenBatch(inputTokens: [InputTokenModel!]!, pairAddress: String!, tolerance: Float!): [TransactionModel!]!
  removeLiquidityLockedToken(inputTokens: InputTokenModel!, attributes: String!, tolerance: Float!): [TransactionModel!]!
  enterFarmLockedToken(inputTokens: [InputTokenModel!]!, farmAddress: String!): TransactionModel!
  exitFarmLockedToken(inputTokens: InputTokenModel!, exitAmount: String): TransactionModel!
  claimRewardsFarmLockedToken(inputTokens: InputTokenModel!): TransactionModel!
  farms: [FarmVersions!]!
  farmTokenAttributes(farmAddress: String!, identifier: String!, attributes: String!): FarmTokenAttributes!
  getRewardsForPosition(farmsPositions: BatchFarmRewardsComputeArgs!): [RewardsModel!]!
  getExitFarmTokens(args: CalculateRewardsArgs!): ExitFarmTokensModel!
  mergeFarmTokens(farmAddress: String!, payments: [InputTokenModel!]!): TransactionModel!
  endProduceRewards(farmStakeAddress: String!): TransactionModel!
  setPerBlockRewardAmount(farmStakeAddress: String!, perBlockAmount: String!): TransactionModel!
  startProduceRewards(farmStakeAddress: String!): TransactionModel!
  setPenaltyPercent(farmStakeAddress: String!, percent: Float!): TransactionModel!
  setMinimumFarmingEpochs(farmStakeAddress: String!, epochs: Float!): TransactionModel!
  setTransferExecGasLimit(farmStakeAddress: String!, gasLimit: Float!): TransactionModel!
  setBurnGasLimit(farmStakeAddress: String!, gasLimit: Float!): TransactionModel!
  pauseFarm(farmAddress: String!): TransactionModel!
  resumeFarm(farmAddress: String!): TransactionModel!
  registerFarmToken(farmStakeAddress: String!, tokenDisplayName: String!, tokenTicker: String!, decimals: Float!): TransactionModel!
  setLocalRolesFarmToken(farmStakeAddress: String!): TransactionModel!
  enterFarm(farmAddress: String!, tokens: [InputTokenModel!]!, lockRewards: Boolean): TransactionModel!
  exitFarm(farmAddress: String!, farmTokenID: String!, farmTokenNonce: Int!, amount: String!, lockRewards: Boolean = false, withPenalty: Boolean = false, exitAmount: String): TransactionModel!
  claimRewards(farmAddress: String!, farmTokenID: String!, farmTokenNonce: Int!, amount: String!, lockRewards: Boolean = false): TransactionModel!
  compoundRewards(farmAddress: String!, farmTokenID: String!, farmTokenNonce: Int!, amount: String!, lockRewards: Boolean = false): TransactionModel!
  migrateToNewFarm(farmAddress: String!, farmTokenID: String!, farmTokenNonce: Int!, amount: String!, lockRewards: Boolean = false, withPenalty: Boolean = false, exitAmount: String): TransactionModel!
  setFarmMigrationConfig(oldFarmAddress: String!, oldFarmTokenID: String!, newFarmAddress: String!, newLockedFarmAddress: String!): TransactionModel!
  stopRewardsAndMigrateRps(farmAddress: String!): TransactionModel!
  simpleLockEnergy: SimpleLockEnergyModel!
  userEnergy(vmQuery: Boolean): EnergyModel!
  penaltyAmount(inputToken: InputTokenModel!, newLockPeriod: Float!, vmQuery: Boolean): String!
  lockTokensEnergy(inputTokens: InputTokenModel!, lockEpochs: Int!): TransactionModel!
  updateLockedTokensEnergy(inputToken: InputTokenModel!, unlockType: UnlockType!, newLockPeriod: Float): TransactionModel!
  mergeTokensEnergy(inputTokens: [InputTokenModel!]!): TransactionModel!
  migrateOldTokens(tokens: [InputTokenModel!]!): TransactionModel!
  updateLockOptions(lockOptions: [Int!]!, remove: Boolean): TransactionModel!
  setPenaltyPercentage(minPenaltyPercentage: Float!, maxPenaltyPercentage: Float!): TransactionModel!
  setFeesBurnPercentage(percentage: Float!): TransactionModel!
  setFeesCollectorAddress(collectorAddress: String!): TransactionModel!
  setOldLockedAssetFactoryAddress(oldLockedAssetFactoryAddress: String!): TransactionModel!
  userEnergyAmount: String!
  weeklyTimekeeping(scAddress: String!): WeekTimekeepingModel!
  weekForEpoch(scAddress: String!, epoch: Float!): WeekForEpochModel!
  feesCollector: FeesCollectorModel!

  """Add or remove known contracts"""
  handleKnownContracts(contractAddresses: [String!]!, remove: Boolean): TransactionModel!

  """Add or remove known tokens"""
  handleKnownTokens(tokenIDs: [String!]!, remove: Boolean): TransactionModel!
  userFeesCollector: UserEntryFeesCollectorModel!
  claimFeesRewards: FeesCollectorTransactionModel!
  updateEnergyForUser: TransactionModel!
  userLastWeekRewards(energyAmount: String, lockedTokens: String): String!
  swap(tokenInID: String!, tokenOutID: String!, amountIn: String, amountOut: String, tolerance: Float!): AutoRouteModel!
  getLastErrorMessage(stakeAddress: String!): String!
  stakingTokenAttributes(args: DecodeAttributesArgs!): [StakingTokenAttributesModel!]!
  unboundTokenAttributes(args: DecodeAttributesArgs!): [UnbondTokenAttributesModel!]!
  getStakingRewardsForPosition(stakingPositions: BatchFarmRewardsComputeArgs!): [StakingRewardsModel!]!
  getOptimalCompoundFrequency(stakeAddress: String!, amount: String!, timeInterval: Float!): OptimalCompoundModel!
  stakingFarms: [StakingModel!]!
  stakeFarm(farmStakeAddress: String!, payments: [InputTokenModel!]!): TransactionModel!
  unstakeFarm(farmStakeAddress: String!, payment: InputTokenModel!): TransactionModel!
  setMaxApr(farmStakeAddress: String!, maxApr: Float!): TransactionModel!
  setMinUnbondEpochs(farmStakeAddress: String!, minUnboundEpoch: Float!): TransactionModel!
  addAddressToWhitelist(farmStakeAddress: String!, address: String!): TransactionModel!
  removeAddressFromWhitelist(farmStakeAddress: String!, address: String!): TransactionModel!
  pauseStaking(farmStakeAddress: String!): TransactionModel!
  resumeStaking(farmStakeAddress: String!): TransactionModel!
  unbondFarm(farmStakeAddress: String!, payment: InputTokenModel!): TransactionModel!
  claimStakingRewards(farmStakeAddress: String!, payment: InputTokenModel!): TransactionModel!
  claimStakingRewardsWithNewValue(farmStakeAddress: String!, payment: InputTokenModel!, newValue: String!): TransactionModel!
  compoundStakingRewards(farmStakeAddress: String!, payment: InputTokenModel!): TransactionModel!
  topUpRewards(farmStakeAddress: String!, payment: InputTokenModel!): TransactionModel!
  mergeStakeFarmTokens(farmStakeAddress: String!, payments: [InputTokenModel!]!): TransactionModel!
  dualYieldTokenAttributes(args: DecodeAttributesArgs!): [DualYieldTokenAttributesModel!]!
  stakingProxies: [StakingProxyModel!]!
  stakeFarmTokens(proxyStakingAddress: String!, payments: [InputTokenModel!]!): TransactionModel!
  claimDualYield(proxyStakingAddress: String!, payments: [InputTokenModel!]!): TransactionModel!
  unstakeFarmTokens(proxyStakingAddress: String!, payment: InputTokenModel!, attributes: String!, tolerance: Float!): TransactionModel!
  getDualYieldRewardsForPosition(proxyStakingPositions: BatchFarmRewardsComputeArgs!): [DualYieldRewardsModel!]!
  getUnstakeTokensReceived(position: CalculateRewardsArgs!): UnstakeFarmTokensReceiveModel!
  distribution: DistributionModel!
  claimLockedAssets: TransactionModel!
  distributedLockedAssets: String!
  proxy: [ProxyModel!]!
  addLiquidityProxyBatch(pairAddress: String!, tokens: [InputTokenModel!]!, tolerance: Float!): [TransactionModel!]!
  addLiquidityProxy(pairAddress: String!, tokens: [InputTokenModel!]!, tolerance: Float!): TransactionModel!
  removeLiquidityProxy(pairAddress: String!, wrappedLpTokenID: String!, wrappedLpTokenNonce: Int!, liquidity: String!, tolerance: Float!): [TransactionModel!]!
  enterFarmProxy(farmAddress: String!, tokens: [InputTokenModel!]!, lockRewards: Boolean): TransactionModel!
  exitFarmProxy(farmAddress: String!, wrappedFarmTokenID: String!, wrappedFarmTokenNonce: Int!, amount: String!, exitAmount: String, lockRewards: Boolean = false, withPenalty: Boolean = false): TransactionModel!
  claimFarmRewardsProxy(farmAddress: String!, wrappedFarmTokenID: String!, wrappedFarmTokenNonce: Int!, amount: String!, lockRewards: Boolean = false): TransactionModel!
  mergeWrappedLpTokens(tokens: [InputTokenModel!]!): TransactionModel!
  mergeWrappedFarmTokens(farmAddress: String!, tokens: [InputTokenModel!]!): TransactionModel!
  compoundRewardsProxy(farmAddress: String!, tokenID: String!, tokenNonce: Int!, amount: String!, lockRewards: Boolean = false): TransactionModel!
  migrateToNewFarmProxy(farmAddress: String!, wrappedFarmTokenID: String!, wrappedFarmTokenNonce: Int!, amount: String!, exitAmount: String, lockRewards: Boolean = false, withPenalty: Boolean = false): TransactionModel!
  wrappedLpTokenAttributes(args: DecodeAttributesArgs!): [WrappedLpTokenAttributesModel!]!
  wrappedFarmTokenAttributes(args: DecodeAttributesArgs!): [WrappedFarmTokenAttributesModel!]!
  wrappedLpTokenAttributesV2(args: DecodeAttributesArgs!): [WrappedLpTokenAttributesModelV2!]!
  wrappedFarmTokenAttributesV2(args: DecodeAttributesArgs!): [WrappedFarmTokenAttributesModelV2!]!
  lockedAssetFactory: LockedAssetModel!
  lockAssets(inputToken: InputTokenModel!): TransactionModel!
  unlockAssets(lockedTokenID: String!, lockedTokenNonce: Int!, amount: String!): TransactionModel!
  mergeLockedAssetTokens(tokens: [InputTokenModel!]!): TransactionModel!
  decodeLockedAssetAttributes(args: DecodeAttributesArgs!): [LockedAssetAttributesModel!]!
  metabondingStaking: MetabondingStakingModel!
  metabondingStakedPosition: UserEntryModel!
  stakeLockedAssetMetabonding(inputTokens: InputTokenModel!): TransactionModel!
  unstakeMetabonding(unstakeAmount: String!): TransactionModel!
  unbondMetabonding: TransactionModel!
  priceDiscoveryContracts: [PriceDiscoveryModel!]!
  depositBatchOnPriceDiscovery(priceDiscoveryAddress: String!, inputTokens: InputTokenModel!): [TransactionModel!]!
  depositOnPriceDiscovery(priceDiscoveryAddress: String!, inputTokens: InputTokenModel!): TransactionModel!
  withdrawBatchFromPriceDiscovery(priceDiscoveryAddress: String!, inputTokens: InputTokenModel!): [TransactionModel!]!
  withdrawFromPriceDiscovery(priceDiscoveryAddress: String!, inputTokens: InputTokenModel!): TransactionModel!
  redeemTokensBatchFromPriceDiscovery(priceDiscoveryAddress: String!, inputTokens: InputTokenModel!): [TransactionModel!]!
  redeemTokensFromPriceDiscovery(priceDiscoveryAddress: String!, inputTokens: InputTokenModel!): TransactionModel!
  closingValues(priceDiscoveryAddress: String!, metric: String!, bucket: PDMetricsBuckets!): [HistoricDataModel!]!
  userTokens(offset: Int! = 0, limit: Int! = 10): [UserToken!]!
  nfts(offset: Int! = 0, limit: Int! = 10): [UserNftTokens!]!
  userOutdatedContracts(skipFeesCollector: Boolean): [OutdatedContract!]!
  updateEnergy(includeAllContracts: Boolean, skipFeesCollector: Boolean): TransactionModel
  userCustomTokens(offset: Int! = 0, limit: Int! = 10, tokens: [DcdtTokenInput!]!): [UserToken!]!
  userCustomNftTokens(offset: Int! = 0, limit: Int! = 10, nfts: [NftTokenInput!]!): [UserNftTokens!]!
  userNfts(offset: Int! = 0, limit: Int! = 10): UserNftsModel!
  lockedTokenWrapper: LockedTokenWrapperModel!
  unwrapLockedToken(inputTokens: InputTokenModel!): TransactionModel!
  wrapLockedToken(inputTokens: InputTokenModel!): TransactionModel!
  getTokenPriceUSD(tokenID: String!): String!
  totalValueLockedUSD: String!
  totalValueStakedUSD: String!
  totalLockedValueUSDFarms: String!
  totalLockedMexStakedUSD: String!
  totalTokenSupply(tokenID: String!): String!
  totalAggregatedRewards(days: Int!): String!
  getFeeTokenBurned(tokenID: String!, time: String!): String!
  getPenaltyTokenBurned(tokenID: String!, time: String!): String!
  latestCompleteValues(series: String!, metric: String!, time: String, start: String, bin: String): [HistoricDataModel!]!
  sumCompleteValues(series: String!, metric: String!, time: String, start: String, bin: String): [HistoricDataModel!]!
  values24h(series: String!, metric: String!, time: String, start: String, bin: String): [HistoricDataModel!]!
  values24hSum(series: String!, metric: String!, time: String, start: String, bin: String): [HistoricDataModel!]!
  latestHistoricData(series: String!, metric: String!, time: String, start: String, bin: String): [HistoricDataModel!]! @deprecated(reason: "New optimized query will be available soon.")
  latestBinnedHistoricData(series: String!, metric: String!, time: String, start: String, bin: String): [HistoricDataModel!]! @deprecated(reason: "New optimized query will be available soon.")
  pairsDayDatas(pairAddress: String): [PairDayDataModel!]!
  tokenUnstake: TokenUnstakeModel!
  getUnlockedTokensForUser: [UnstakePairModel!]!
  claimUnlockedTokens: TransactionModel!
  cancelUnbond: TransactionModel!
  escrowContract: EscrowModel!

  """Get all scheduled transfers for a given user"""
  scheduledTransfers: [ScheduledTransferModel!]!

  """Get all senders for a given receiver"""
  escrowSenders: [String!]!

  """Get all receivers for a given sender"""
  escrowReceivers(sender: String): [String!]!

  """Get sender last transfer epoch; used for cooldown period"""
  senderLastTransferEpoch: Float
  receiverLastTransferEpoch(
    """Get receiver last transfer epoch; used for cooldown period"""
    receiver: String
  ): Float

  """Generate transaction to receive escrowed tokens"""
  escrowReceive(senderAddress: String!): TransactionModel!

  """Generate transaction to cancel escrowed transfers; used only by admins"""
  cancelEscrowTransfer(sender: String!, receiver: String!): TransactionModel!

  """Generate transaction to lock tokens in escrow"""
  escrowTransfer(receiver: String!, inputTokens: [InputTokenModel!]!): TransactionModel!

  """Get address permissions"""
  escrowPermissions: [SCPermissions!]!
  vote(contractAddress: String!, proposalId: Float!, vote: Float!): TransactionModel!
  governanceContracts(identifiers: [String!], contracts: [String!], type: String): [GovernanceTypes!]!
  rootHash(contractAddress: String!, proposalId: Float!, vote: Float!): String!
  totalBalance(contractAddress: String!, proposalId: Float!, vote: Float!): String!
}

input SetLocalRoleOwnerArgs {
  tokenID: String!
  address: String!
  roles: [DcdtLocalRole!]!
}

enum DcdtLocalRole {
  None
  Mint
  Burn
  NftCreate
  NftAddQuantity
  NftBurn
}

input InputTokenModel {
  tokenID: String!
  nonce: Int!
  amount: String!
  attributes: String
}

input DecodeAttributesArgs {
  batchAttributes: [DecodeAttributesModel!]!
}

input DecodeAttributesModel {
  identifier: String!
  attributes: String!
}

union FarmVersions = FarmModelV1_2 | FarmModelV1_3 | FarmCustomModel | FarmModelV2 | BaseFarmModel

type FarmModelV1_2 {
  address: String!
  farmedToken: DcdtToken!
  farmedTokenPriceUSD: String!
  farmToken: NftCollection!
  farmTokenPriceUSD: String!
  farmingToken: DcdtToken!
  farmingTokenPriceUSD: String!
  produceRewardsEnabled: Boolean!
  perBlockRewards: String!
  farmTokenSupply: String!
  penaltyPercent: Int!
  minimumFarmingEpochs: Int!
  rewardPerShare: String!
  rewardReserve: String!
  lastRewardBlockNonce: Int!
  divisionSafetyConstant: String!
  totalValueLockedUSD: String!
  state: String!
  version: String!
  burnGasLimit: String
  transferExecGasLimit: String
  pair: PairModel
  lastErrorMessage: String
  farmingTokenReserve: String!
  undistributedFees: String!
  currentBlockFee: String!
  aprMultiplier: Int!
  lockedAssetFactory: LockedAssetModel!
  lockedRewardsAPR: String!
  unlockedRewardsAPR: String!
  lockedFarmingTokenReserveUSD: String!
  unlockedFarmingTokenReserveUSD: String!
  lockedFarmingTokenReserve: String!
  unlockedFarmingTokenReserve: String!
  migrationConfig: FarmMigrationConfig
}

type FarmModelV1_3 {
  address: String!
  farmedToken: DcdtToken!
  farmedTokenPriceUSD: String!
  farmToken: NftCollection!
  farmTokenPriceUSD: String!
  farmingToken: DcdtToken!
  farmingTokenPriceUSD: String!
  produceRewardsEnabled: Boolean!
  perBlockRewards: String!
  farmTokenSupply: String!
  penaltyPercent: Int!
  minimumFarmingEpochs: Int!
  rewardPerShare: String!
  rewardReserve: String!
  lastRewardBlockNonce: Int!
  divisionSafetyConstant: String!
  totalValueLockedUSD: String!
  state: String!
  version: String!
  burnGasLimit: String
  transferExecGasLimit: String
  pair: PairModel
  lastErrorMessage: String
  apr: String!
  lockedAssetFactory: LockedAssetModel
  rewardType: String!
  migrationConfig: FarmMigrationConfig
}

type FarmCustomModel {
  address: String!
  farmedToken: DcdtToken!
  farmedTokenPriceUSD: String!
  farmToken: NftCollection!
  farmTokenPriceUSD: String!
  farmingToken: DcdtToken!
  farmingTokenPriceUSD: String!
  produceRewardsEnabled: Boolean!
  perBlockRewards: String!
  farmTokenSupply: String!
  penaltyPercent: Int!
  minimumFarmingEpochs: Int!
  rewardPerShare: String!
  rewardReserve: String!
  lastRewardBlockNonce: Int!
  divisionSafetyConstant: String!
  totalValueLockedUSD: String!
  state: String!
  version: String!
  burnGasLimit: String
  transferExecGasLimit: String
  pair: PairModel
  lastErrorMessage: String
  requireWhitelist: Boolean!
}

type FarmModelV2 {
  address: String!
  farmedToken: DcdtToken!
  farmedTokenPriceUSD: String!
  farmToken: NftCollection!
  farmTokenPriceUSD: String!
  farmingToken: DcdtToken!
  farmingTokenPriceUSD: String!
  produceRewardsEnabled: Boolean!
  perBlockRewards: String!
  farmTokenSupply: String!
  penaltyPercent: Int!
  minimumFarmingEpochs: Int!
  rewardPerShare: String!
  rewardReserve: String!
  lastRewardBlockNonce: Int!
  divisionSafetyConstant: String!
  totalValueLockedUSD: String!
  state: String!
  version: String!
  burnGasLimit: String
  transferExecGasLimit: String
  pair: PairModel
  lastErrorMessage: String
  boostedYieldsRewardsPercenatage: Int!
  boostedYieldsFactors: BoostedYieldsFactors!
  lockingScAddress: String
  lockEpochs: String
  undistributedBoostedRewards: String!
  undistributedBoostedRewardsClaimed: String!
  energyFactoryAddress: String!
  rewardType: String!
  time: WeekTimekeepingModel!
  accumulatedRewards: String!
  boosterRewards: [GlobalInfoByWeekModel!]!
  lastGlobalUpdateWeek: Float!
  baseApr: String!
  optimalEnergyPerLp: String!
}

type BaseFarmModel {
  address: String!
  farmedToken: DcdtToken!
  farmedTokenPriceUSD: String!
  farmToken: NftCollection!
  farmTokenPriceUSD: String!
  farmingToken: DcdtToken!
  farmingTokenPriceUSD: String!
  produceRewardsEnabled: Boolean!
  perBlockRewards: String!
  farmTokenSupply: String!
  penaltyPercent: Int!
  minimumFarmingEpochs: Int!
  rewardPerShare: String!
  rewardReserve: String!
  lastRewardBlockNonce: Int!
  divisionSafetyConstant: String!
  totalValueLockedUSD: String!
  state: String!
  version: String!
  burnGasLimit: String
  transferExecGasLimit: String
  pair: PairModel
  lastErrorMessage: String
}

input BatchFarmRewardsComputeArgs {
  farmsPositions: [CalculateRewardsArgs!]!
}

input CalculateRewardsArgs {
  farmAddress: String!
  user: String!
  liquidity: String!
  identifier: String!
  attributes: String!
  vmQuery: Boolean! = false
}

enum UnlockType {
  TERM_UNLOCK
  EARLY_UNLOCK
  REDUCE_PERIOD
}

enum PDMetricsBuckets {
  MINUTE_1
  MINUTES_5
  MINUTES_30
  HOUR_1
}

union UserNftTokens = UserLockedAssetToken | UserFarmToken | UserLockedLPToken | UserLockedFarmToken | UserLockedLPTokenV2 | UserLockedFarmTokenV2 | UserStakeFarmToken | UserUnbondFarmToken | UserDualYiledToken | UserRedeemToken | UserLockedDcdtToken | UserLockedSimpleLpToken | UserLockedSimpleFarmToken | UserLockedTokenEnergy | UserWrappedLockedToken | UserNftToken

type UserNftToken implements INFTToken {
  identifier: String!
  collection: String!
  ticker: String!
  decimals: Int!
  timestamp: Int
  attributes: String!
  nonce: Int!
  type: String!
  name: String!
  creator: String!
  royalties: Int
  uris: [String!]
  url: String
  tags: [String!]
  balance: String!
  assets: AssetsModel
  valueUSD: String!
}

input DcdtTokenInput {
  identifier: String!
  name: String!
  ticker: String!
  owner: String!
  minted: String
  burnt: String
  initialMinted: String
  decimals: Float!
  price: String
  supply: String
  circulatingSupply: String
  transactions: Int!
  accounts: Int!
  isPaused: Boolean!
  canUpgrade: Boolean!
  canMint: Boolean!
  canBurn: Boolean!
  canChangeOwner: Boolean!
  canPause: Boolean!
  canFreeze: Boolean!
  canWipe: Boolean!
  type: String
  balance: String
}

input NftTokenInput {
  identifier: String!
  collection: String!
  ticker: String!
  decimals: Int!
  timestamp: Int
  attributes: String!
  nonce: Int!
  type: String!
  name: String!
  creator: String!
  royalties: Int
  uris: [String!]
  url: String
  tags: [String!]
  balance: String!
}

enum SCPermissions {
  NONE
  OWNER
  ADMIN
  PAUSE
}

union GovernanceTypes = GovernanceTokenSnapshotContract | GovernanceEnergyContract

type GovernanceTokenSnapshotContract {
  address: String!
  minFeeForPropose: String!
  quorum: String!
  votingDelayInBlocks: Int!
  votingPeriodInBlocks: Int!
  feeToken: DcdtToken!
  withdrawPercentageDefeated: Int!
  proposals(proposalId: Int): [GovernanceProposalModel!]!
  vetoPercentageLimit: Int!
}

type GovernanceEnergyContract {
  address: String!
  minFeeForPropose: String!
  quorum: String!
  votingDelayInBlocks: Int!
  votingPeriodInBlocks: Int!
  feeToken: DcdtToken!
  withdrawPercentageDefeated: Int!
  proposals(proposalId: Int): [GovernanceProposalModel!]!
  vetoPercentageLimit: Int!
  minEnergyForPropose: String!
  feesCollectorAddress: String!
  energyFactoryAddress: String!
}

type Subscription {
  swapFixedInputEvent: SwapFixedInputEventModel!
  swapFixedOutputEvent: SwapFixedOutputEventModel!
  addLiquidityEvent: AddLiquidityEventModel!
  removeLiquidityEvent: RemoveLiquidityEventModel!
  swapNoFeeEvent: SwapNoFeeEventModel!
  enterFarmEvent: FarmEventModelV1_3!
  exitFarmEvent: FarmEventModelV1_3!
  claimRewardsEvent: RewardsFarmEventModelV1_3!
  compoundRewardsEvent: RewardsFarmEventModelV1_3!
  addLiquidityProxyEvent: AddLiquidityProxyEventModel!
  removeLiquidityProxyEvent: PairProxyEventModel!
  enterFarmProxyEvent: EnterFarmProxyEventModel!
  exitFarmProxyEvent: ExitFarmProxyEventModel!
  claimRewardsProxyEvent: ClaimRewardsProxyEventModel!
  compoundRewardsProxyEvent: RewardsProxyEventModel!
  updatedEnergy: UpdatedEnergyEventModel!
}